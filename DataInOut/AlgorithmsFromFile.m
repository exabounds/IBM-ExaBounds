(*******************************************************************************
 * (C) Copyright IBM Corporation 2017
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Algorithms & Machines team
 *******************************************************************************)
 
 (* Mathematica Package *)
(* This package contains functions to load algorithm properties from files generated by the application characterization framework *)

(* DEPRECATED *)
(* Replaced by JSON files *)

BeginPackage["AlgorithmsFromFile`"]
(* Exported symbols added here with SymbolName::usage *)  

Needs["ExaBoundsGeneric`"];
Needs["AlgorithmProperties`"];  

LoadAlgorithmFromFiles::usage =
	"LoadAlgorithmFromFiles[basePath_, baseName_]"

Begin["`Private`"] (* Begin Private Context *) 

(* We define a set of global variables which indicate the respective START and END sections in the application characterization output *)
(* NOTE: there are some deliberate typos here, as these are inserted by the application characterization tool *)
statisticsStart = "sim: ** START Instruction Mix ** thread 0 ** processor 0"; (*"** START Simulation Statistics **"*)
statisticsEnd = "sim: **  END Instruction Mix ** thread 0 ** processor 0";
iReuseStart = "sim: ** START Inst Temp Reuse CDF ** thread 0 ** processor 0";
iReuseEnd = "sim: ** END Inst Temp Reuse CDF ** thread 0 ** processor 0";
dReuseStart = "sim: ** START Data Temp Reuse CDF ** thread 0 ** processor 0";
dReuseEnd = "sim: ** END Data Temp Reuse CDF ** thread 0 ** processor 0";
regStart = "sim: ** START Register Counting ** thread 0 ** processor 0";
regEnd = "sim: **  END Register Counting ** thread 0 ** processor 0";

(* Function to load algorithm properties from files. It expects the following files to be present:
${basePath}\dreuse\${baseName}_data_temp_reuse
${basePath}\ilp\${baseName}_ilp
${basePath}\ireuse\{$baseName}_inst_temp_reuse
${basePath}\regcount\${baseName}_register_counting
${basePath}\${baseName}_instruction_mix
*)
LoadAlgorithmFromFiles[basePath_, baseName_] :=
Module[{instructionmixFile, dreuseFile, ilpFile, ireuseFile, regcountFile, keyValueList},
	instructionmixFile = FileNameJoin[{basePath, baseName<>"_instruction_mix"}];
	dreuseFile = FileNameJoin[{basePath, "dreuse"(*, "dreuse-cache-line-128"*), baseName<>"_data_temp_reuse"}];
	ilpFile = FileNameJoin[{basePath, "ilp", baseName<>"-ilpstats"}];
	ireuseFile = FileNameJoin[{basePath, "ireuse", baseName<>"_inst_temp_reuse"}];
	regcountFile = FileNameJoin[{basePath, "regcount", baseName<>"_register_counting"}];
	
	If [!FileExistsQ[instructionmixFile], MessageDialog["File " <> instructionmixFile <> " does not exist"]; Return[Null]];
	If [!FileExistsQ[dreuseFile], MessageDialog["File " <> dreuseFile <> " does not exist"]; Return[Null]];
	If [!FileExistsQ[ilpFile], MessageDialog["File " <> ilpFile <> " does not exist"]; Return[Null]];
	If [!FileExistsQ[ireuseFile], MessageDialog["File " <> ireuseFile <> " does not exist"]; Return[Null]];
	If [!FileExistsQ[regcountFile], MessageDialog["File " <> regcountFile <> " does not exist"]; Return[Null]];
	
	keyValueList = Catch[
		Join[
			ReadInstructionMix[instructionmixFile],
				{
					{"D0ireuse", ReadReuse[ireuseFile, iReuseStart, iReuseEnd]},
					{"D0dreuse", ReadReuse[dreuseFile, dReuseStart, dReuseEnd]}
				},
			ReadILP0[ilpFile],
			ReadRegCount[regcountFile]
		], "IncorrectData"];
	
	If [keyValueList == {}, Return[keyValueList]]; (* Return empty list if emtpy *)

	(* Fill in missing defaults. NOTE: TLP analysis ommited, which was used as ALP1 by Phillip, but that is likely wrong *)
	keyValueList = ExaBoundsMergeState[GetDefaultAlgorithmProperties[], keyValueList];
	
	Return[keyValueList];
];

ReadBoundedList[fileName_, startString_, endString_, tupleType_] :=
Module[{file, string, entry, list},
	file = OpenRead[fileName];
	
	(* Read in all key-value pairs *)
	list = {};
	(* Find start of statistics section *)
	string = Find[file, startString];
	If[string == EndOfFile, CellPrint["Unexpected end of file, could not find \"" <> startString <> "\" in file " <> fileName]; Close[file]; Throw[{}, "IncorrectData"]];
	
	(* Read in properties *)
	While[True,
		string = Read[file, {String}]; (* read line *)
		If[string == EndOfFile, CellPrint["Unexpected end of file, could not find \"" <> endString <> "\" in file " <> fileName]; Close[file]; Throw[{}, "IncorrectData"]];
		If[string[[1]] == endString, Break[]]; (* Exit loop on reuse end *)
		entry = Read[StringToStream[string[[1]]], tupleType]; (* Convert to tupleType *)
		list = Join[list, {entry}];
	];
	
	Close[file];
	
	Return[list];
];

(* Read unbounded list (valid data until EOF *)
ReadUnboundedList[fileName_, startString_, tupleType_] :=
Module[{file, string, entry, list},
	file = OpenRead[fileName];
	
	(* Read in all key-value pairs *)
	list = {};
	(* Find start of statistics section *)
	string = Find[file, startString];
	If[string == EndOfFile, CellPrint["Unexpected end of file, could not find \"" <> startString <> "\" in file " <> fileName]; Close[file]; Throw[{}, "IncorrectData"]];
	
	(* Read in properties *)
	While[True,
		string = Read[file, {String}]; (* read line *)
		If[string == EndOfFile, Break[]];
		entry = Read[StringToStream[string[[1]]], tupleType]; (* Convert to tupleType *)
		list = Join[list, {entry}];
	];
	
	Close[file];
	
	Return[list];
];

(* Read list (valid data from start until EOF *)
ReadFileList[fileName_, tupleType_] :=
Module[{file, string, entry, list},
	file = OpenRead[fileName];
	
	(* Read in all key-value pairs *)
	list = {};
	
	(* Read in properties *)
	While[True,
		string = Read[file, {String}]; (* read line *)
		If[string == EndOfFile, Break[]];
		entry = Read[StringToStream[string[[1]]], tupleType]; (* Convert to tupleType *)
		list = Join[list, {entry}];
	];
	
	Close[file];
	
	Return[list];
];

ReadInstructionMix[fileName_] :=
Module[{keyValueList, totalInstructions},
	keyValueList = ReadBoundedList[fileName, statisticsStart, statisticsEnd, {Word, Number}]; (*statisticsEnd*)
	
    totalInstructions = GetKeyValue[keyValueList, "instructions_analyzed"];
	(* Convert data to ExaBounds algorithm properties *)
	Return[{
		{"LSys", totalInstructions},
 		{"F0addr", GetKeyValue[keyValueList, "address_arith_instructions"] / totalInstructions},
 		{"F0int", GetKeyValue[keyValueList, "total_integer_arith_instructions"] / totalInstructions},
 		{"F0fp", GetKeyValue[keyValueList, "total_fp_arith_instructions"] / totalInstructions},
 		{"F0control", GetKeyValue[keyValueList, "control_instructions"] / totalInstructions},
 		{"F0mem", (GetKeyValue[keyValueList, "load_instructions"] + GetKeyValue[keyValueList, "store_instructions"]) / totalInstructions},
 		{"F0load", GetKeyValue[keyValueList, "load_instructions"] / totalInstructions},
 		{"F0store", GetKeyValue[keyValueList, "store_instructions"] / totalInstructions},
 		{"F0other", GetKeyValue[keyValueList, "misc_instructions"] / totalInstructions},
 		{"F0intmul", GetKeyValue[keyValueList, "int_mul_instructions"] / totalInstructions},
 		{"F0intdiv", (GetKeyValue[keyValueList, "int_udiv_instructions"]+GetKeyValue[keyValueList, "int_sdiv_instructions"]) / totalInstructions},
 		{"F0fpmul", GetKeyValue[keyValueList, "fp_mul_instructions"] / totalInstructions},
 		{"F0fpdiv", GetKeyValue[keyValueList, "fp_div_instructions"] / totalInstructions}
	}];
];

ReadReuse[fileName_, start_, end_] :=
Module[{},
	(* Returen CDF *)
	Return[ReadBoundedList[fileName, start, end, {Number, Number}]];
];

ReadILP0[fileName_] :=
Module[{keyValueList},
	(* Right version: keyValueList = ReadBoundedList[fileName, statisticsStart, statisticsEnd, {Word, Number}]; *)
	(* Wrong version due to small error in current LLVM files: *)
	keyValueList = ReadFileList[fileName, {Word, Number}];
	
	Return[{{"ILP0", GetKeyValue[keyValueList, "arithmetic_mean_without_ctrl"]}}]; (*harmonic_mean?*)
];

ReadRegCount[fileName_] :=
Module[{keyValueListReg, keyValueListInstr},
	keyValueListReg = ReadBoundedList[fileName, regStart, regEnd, {Word, Word, Word, Number}];
	keyValueListInstr = ReadBoundedList[fileName, statisticsStart, statisticsEnd, {Word, Number}];
	
	(* Convert keyValueListReg to a true key-value list *)
	
	keyValueListReg = Join[{StringJoin[#[[1 ;; 3]]]}, {#[[4]]}] & /@ keyValueListReg;
	
	Return[{
		{"F0regreads", GetKeyValue[keyValueListReg, "#registerreads:"] / GetKeyValue[keyValueListInstr, "instructions_analyzed"]},
		{"F0regwrites", GetKeyValue[keyValueListReg, "#registerwrites:"] / GetKeyValue[keyValueListInstr, "instructions_analyzed"]}
	}];
];

End[] (* End Private Context *)

EndPackage[]